/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "tracetest_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace jaegertracing { namespace crossdock { namespace thrift {

int _kTransportValues[] = {
  Transport::HTTP,
  Transport::TCHANNEL,
  Transport::DUMMY
};
const char* _kTransportNames[] = {
  "HTTP",
  "TCHANNEL",
  "DUMMY"
};
const std::map<int, const char*> _Transport_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTransportValues, _kTransportNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Transport::type& val) {
  std::map<int, const char*>::const_iterator it = _Transport_VALUES_TO_NAMES.find(val);
  if (it != _Transport_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


Downstream::~Downstream() throw() {
}


void Downstream::__set_serviceName(const std::string& val) {
  this->serviceName = val;
}

void Downstream::__set_serverRole(const std::string& val) {
  this->serverRole = val;
}

void Downstream::__set_host(const std::string& val) {
  this->host = val;
}

void Downstream::__set_port(const std::string& val) {
  this->port = val;
}

void Downstream::__set_transport(const Transport::type val) {
  this->transport = val;
}

void Downstream::__set_downstream(const std::shared_ptr<Downstream>& val) {
  this->downstream = val;
__isset.downstream = true;
}
std::ostream& operator<<(std::ostream& out, const Downstream& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Downstream::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_serviceName = false;
  bool isset_serverRole = false;
  bool isset_host = false;
  bool isset_port = false;
  bool isset_transport = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serviceName);
          isset_serviceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverRole);
          isset_serverRole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          isset_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->transport = (Transport::type)ecast0;
          isset_transport = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->downstream->read(iprot);
          this->__isset.downstream = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_serviceName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serverRole)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_host)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_transport)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Downstream::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Downstream");

  xfer += oprot->writeFieldBegin("serviceName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serviceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverRole", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->serverRole);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transport", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->transport);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.downstream) {
    xfer += oprot->writeFieldBegin("downstream", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->downstream->write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Downstream &a, Downstream &b) {
  using ::std::swap;
  swap(a.serviceName, b.serviceName);
  swap(a.serverRole, b.serverRole);
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.transport, b.transport);
  swap(a.downstream, b.downstream);
  swap(a.__isset, b.__isset);
}

Downstream::Downstream(const Downstream& other1) {
  serviceName = other1.serviceName;
  serverRole = other1.serverRole;
  host = other1.host;
  port = other1.port;
  transport = other1.transport;
  downstream = other1.downstream;
  __isset = other1.__isset;
}
Downstream& Downstream::operator=(const Downstream& other2) {
  serviceName = other2.serviceName;
  serverRole = other2.serverRole;
  host = other2.host;
  port = other2.port;
  transport = other2.transport;
  downstream = other2.downstream;
  __isset = other2.__isset;
  return *this;
}
void Downstream::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Downstream(";
  out << "serviceName=" << to_string(serviceName);
  out << ", " << "serverRole=" << to_string(serverRole);
  out << ", " << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ", " << "transport=" << to_string(transport);
  out << ", " << "downstream="; (__isset.downstream ? (out << to_string(downstream)) : (out << "<null>"));
  out << ")";
}


StartTraceRequest::~StartTraceRequest() throw() {
}


void StartTraceRequest::__set_serverRole(const std::string& val) {
  this->serverRole = val;
}

void StartTraceRequest::__set_sampled(const bool val) {
  this->sampled = val;
}

void StartTraceRequest::__set_baggage(const std::string& val) {
  this->baggage = val;
}

void StartTraceRequest::__set_downstream(const Downstream& val) {
  this->downstream = val;
}
std::ostream& operator<<(std::ostream& out, const StartTraceRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StartTraceRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_serverRole = false;
  bool isset_sampled = false;
  bool isset_baggage = false;
  bool isset_downstream = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverRole);
          isset_serverRole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sampled);
          isset_sampled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->baggage);
          isset_baggage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->downstream.read(iprot);
          isset_downstream = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_serverRole)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sampled)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_baggage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_downstream)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StartTraceRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StartTraceRequest");

  xfer += oprot->writeFieldBegin("serverRole", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serverRole);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sampled", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->sampled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baggage", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->baggage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("downstream", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->downstream.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StartTraceRequest &a, StartTraceRequest &b) {
  using ::std::swap;
  swap(a.serverRole, b.serverRole);
  swap(a.sampled, b.sampled);
  swap(a.baggage, b.baggage);
  swap(a.downstream, b.downstream);
}

StartTraceRequest::StartTraceRequest(const StartTraceRequest& other3) {
  serverRole = other3.serverRole;
  sampled = other3.sampled;
  baggage = other3.baggage;
  downstream = other3.downstream;
}
StartTraceRequest& StartTraceRequest::operator=(const StartTraceRequest& other4) {
  serverRole = other4.serverRole;
  sampled = other4.sampled;
  baggage = other4.baggage;
  downstream = other4.downstream;
  return *this;
}
void StartTraceRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StartTraceRequest(";
  out << "serverRole=" << to_string(serverRole);
  out << ", " << "sampled=" << to_string(sampled);
  out << ", " << "baggage=" << to_string(baggage);
  out << ", " << "downstream=" << to_string(downstream);
  out << ")";
}


JoinTraceRequest::~JoinTraceRequest() throw() {
}


void JoinTraceRequest::__set_serverRole(const std::string& val) {
  this->serverRole = val;
}

void JoinTraceRequest::__set_downstream(const Downstream& val) {
  this->downstream = val;
__isset.downstream = true;
}
std::ostream& operator<<(std::ostream& out, const JoinTraceRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t JoinTraceRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_serverRole = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverRole);
          isset_serverRole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->downstream.read(iprot);
          this->__isset.downstream = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_serverRole)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t JoinTraceRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("JoinTraceRequest");

  xfer += oprot->writeFieldBegin("serverRole", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serverRole);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.downstream) {
    xfer += oprot->writeFieldBegin("downstream", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->downstream.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(JoinTraceRequest &a, JoinTraceRequest &b) {
  using ::std::swap;
  swap(a.serverRole, b.serverRole);
  swap(a.downstream, b.downstream);
  swap(a.__isset, b.__isset);
}

JoinTraceRequest::JoinTraceRequest(const JoinTraceRequest& other5) {
  serverRole = other5.serverRole;
  downstream = other5.downstream;
  __isset = other5.__isset;
}
JoinTraceRequest& JoinTraceRequest::operator=(const JoinTraceRequest& other6) {
  serverRole = other6.serverRole;
  downstream = other6.downstream;
  __isset = other6.__isset;
  return *this;
}
void JoinTraceRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "JoinTraceRequest(";
  out << "serverRole=" << to_string(serverRole);
  out << ", " << "downstream="; (__isset.downstream ? (out << to_string(downstream)) : (out << "<null>"));
  out << ")";
}


ObservedSpan::~ObservedSpan() throw() {
}


void ObservedSpan::__set_traceId(const std::string& val) {
  this->traceId = val;
}

void ObservedSpan::__set_sampled(const bool val) {
  this->sampled = val;
}

void ObservedSpan::__set_baggage(const std::string& val) {
  this->baggage = val;
}
std::ostream& operator<<(std::ostream& out, const ObservedSpan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ObservedSpan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_traceId = false;
  bool isset_sampled = false;
  bool isset_baggage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->traceId);
          isset_traceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sampled);
          isset_sampled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->baggage);
          isset_baggage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_traceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sampled)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_baggage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ObservedSpan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ObservedSpan");

  xfer += oprot->writeFieldBegin("traceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->traceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sampled", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->sampled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baggage", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->baggage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ObservedSpan &a, ObservedSpan &b) {
  using ::std::swap;
  swap(a.traceId, b.traceId);
  swap(a.sampled, b.sampled);
  swap(a.baggage, b.baggage);
}

ObservedSpan::ObservedSpan(const ObservedSpan& other7) {
  traceId = other7.traceId;
  sampled = other7.sampled;
  baggage = other7.baggage;
}
ObservedSpan& ObservedSpan::operator=(const ObservedSpan& other8) {
  traceId = other8.traceId;
  sampled = other8.sampled;
  baggage = other8.baggage;
  return *this;
}
void ObservedSpan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ObservedSpan(";
  out << "traceId=" << to_string(traceId);
  out << ", " << "sampled=" << to_string(sampled);
  out << ", " << "baggage=" << to_string(baggage);
  out << ")";
}


TraceResponse::~TraceResponse() throw() {
}


void TraceResponse::__set_span(const ObservedSpan& val) {
  this->span = val;
__isset.span = true;
}

void TraceResponse::__set_downstream(const std::shared_ptr<TraceResponse>& val) {
  this->downstream = val;
__isset.downstream = true;
}

void TraceResponse::__set_notImplementedError(const std::string& val) {
  this->notImplementedError = val;
}
std::ostream& operator<<(std::ostream& out, const TraceResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TraceResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_notImplementedError = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->span.read(iprot);
          this->__isset.span = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->downstream->read(iprot);
          this->__isset.downstream = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->notImplementedError);
          isset_notImplementedError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_notImplementedError)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TraceResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TraceResponse");

  if (this->__isset.span) {
    xfer += oprot->writeFieldBegin("span", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->span.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.downstream) {
    xfer += oprot->writeFieldBegin("downstream", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->downstream->write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("notImplementedError", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->notImplementedError);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TraceResponse &a, TraceResponse &b) {
  using ::std::swap;
  swap(a.span, b.span);
  swap(a.downstream, b.downstream);
  swap(a.notImplementedError, b.notImplementedError);
  swap(a.__isset, b.__isset);
}

TraceResponse::TraceResponse(const TraceResponse& other9) {
  span = other9.span;
  downstream = other9.downstream;
  notImplementedError = other9.notImplementedError;
  __isset = other9.__isset;
}
TraceResponse& TraceResponse::operator=(const TraceResponse& other10) {
  span = other10.span;
  downstream = other10.downstream;
  notImplementedError = other10.notImplementedError;
  __isset = other10.__isset;
  return *this;
}
void TraceResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TraceResponse(";
  out << "span="; (__isset.span ? (out << to_string(span)) : (out << "<null>"));
  out << ", " << "downstream="; (__isset.downstream ? (out << to_string(downstream)) : (out << "<null>"));
  out << ", " << "notImplementedError=" << to_string(notImplementedError);
  out << ")";
}

}}} // namespace
