/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "sampling_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace jaegertracing { namespace sampling_manager { namespace thrift {

int _kSamplingStrategyTypeValues[] = {
  SamplingStrategyType::PROBABILISTIC,
  SamplingStrategyType::RATE_LIMITING
};
const char* _kSamplingStrategyTypeNames[] = {
  "PROBABILISTIC",
  "RATE_LIMITING"
};
const std::map<int, const char*> _SamplingStrategyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSamplingStrategyTypeValues, _kSamplingStrategyTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SamplingStrategyType::type& val) {
  std::map<int, const char*>::const_iterator it = _SamplingStrategyType_VALUES_TO_NAMES.find(val);
  if (it != _SamplingStrategyType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


ProbabilisticSamplingStrategy::~ProbabilisticSamplingStrategy() throw() {
}


void ProbabilisticSamplingStrategy::__set_samplingRate(const double val) {
  this->samplingRate = val;
}
std::ostream& operator<<(std::ostream& out, const ProbabilisticSamplingStrategy& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ProbabilisticSamplingStrategy::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_samplingRate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->samplingRate);
          isset_samplingRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_samplingRate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ProbabilisticSamplingStrategy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProbabilisticSamplingStrategy");

  xfer += oprot->writeFieldBegin("samplingRate", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->samplingRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProbabilisticSamplingStrategy &a, ProbabilisticSamplingStrategy &b) {
  using ::std::swap;
  swap(a.samplingRate, b.samplingRate);
}

ProbabilisticSamplingStrategy::ProbabilisticSamplingStrategy(const ProbabilisticSamplingStrategy& other0) {
  samplingRate = other0.samplingRate;
}
ProbabilisticSamplingStrategy& ProbabilisticSamplingStrategy::operator=(const ProbabilisticSamplingStrategy& other1) {
  samplingRate = other1.samplingRate;
  return *this;
}
void ProbabilisticSamplingStrategy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProbabilisticSamplingStrategy(";
  out << "samplingRate=" << to_string(samplingRate);
  out << ")";
}


RateLimitingSamplingStrategy::~RateLimitingSamplingStrategy() throw() {
}


void RateLimitingSamplingStrategy::__set_maxTracesPerSecond(const int16_t val) {
  this->maxTracesPerSecond = val;
}
std::ostream& operator<<(std::ostream& out, const RateLimitingSamplingStrategy& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RateLimitingSamplingStrategy::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxTracesPerSecond = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxTracesPerSecond);
          isset_maxTracesPerSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxTracesPerSecond)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RateLimitingSamplingStrategy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RateLimitingSamplingStrategy");

  xfer += oprot->writeFieldBegin("maxTracesPerSecond", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->maxTracesPerSecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RateLimitingSamplingStrategy &a, RateLimitingSamplingStrategy &b) {
  using ::std::swap;
  swap(a.maxTracesPerSecond, b.maxTracesPerSecond);
}

RateLimitingSamplingStrategy::RateLimitingSamplingStrategy(const RateLimitingSamplingStrategy& other2) {
  maxTracesPerSecond = other2.maxTracesPerSecond;
}
RateLimitingSamplingStrategy& RateLimitingSamplingStrategy::operator=(const RateLimitingSamplingStrategy& other3) {
  maxTracesPerSecond = other3.maxTracesPerSecond;
  return *this;
}
void RateLimitingSamplingStrategy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RateLimitingSamplingStrategy(";
  out << "maxTracesPerSecond=" << to_string(maxTracesPerSecond);
  out << ")";
}


OperationSamplingStrategy::~OperationSamplingStrategy() throw() {
}


void OperationSamplingStrategy::__set_operation(const std::string& val) {
  this->operation = val;
}

void OperationSamplingStrategy::__set_probabilisticSampling(const ProbabilisticSamplingStrategy& val) {
  this->probabilisticSampling = val;
}
std::ostream& operator<<(std::ostream& out, const OperationSamplingStrategy& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OperationSamplingStrategy::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operation = false;
  bool isset_probabilisticSampling = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->operation);
          isset_operation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->probabilisticSampling.read(iprot);
          isset_probabilisticSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_probabilisticSampling)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OperationSamplingStrategy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OperationSamplingStrategy");

  xfer += oprot->writeFieldBegin("operation", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->operation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("probabilisticSampling", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->probabilisticSampling.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OperationSamplingStrategy &a, OperationSamplingStrategy &b) {
  using ::std::swap;
  swap(a.operation, b.operation);
  swap(a.probabilisticSampling, b.probabilisticSampling);
}

OperationSamplingStrategy::OperationSamplingStrategy(const OperationSamplingStrategy& other4) {
  operation = other4.operation;
  probabilisticSampling = other4.probabilisticSampling;
}
OperationSamplingStrategy& OperationSamplingStrategy::operator=(const OperationSamplingStrategy& other5) {
  operation = other5.operation;
  probabilisticSampling = other5.probabilisticSampling;
  return *this;
}
void OperationSamplingStrategy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OperationSamplingStrategy(";
  out << "operation=" << to_string(operation);
  out << ", " << "probabilisticSampling=" << to_string(probabilisticSampling);
  out << ")";
}


PerOperationSamplingStrategies::~PerOperationSamplingStrategies() throw() {
}


void PerOperationSamplingStrategies::__set_defaultSamplingProbability(const double val) {
  this->defaultSamplingProbability = val;
}

void PerOperationSamplingStrategies::__set_defaultLowerBoundTracesPerSecond(const double val) {
  this->defaultLowerBoundTracesPerSecond = val;
}

void PerOperationSamplingStrategies::__set_perOperationStrategies(const std::vector<OperationSamplingStrategy> & val) {
  this->perOperationStrategies = val;
}

void PerOperationSamplingStrategies::__set_defaultUpperBoundTracesPerSecond(const double val) {
  this->defaultUpperBoundTracesPerSecond = val;
__isset.defaultUpperBoundTracesPerSecond = true;
}
std::ostream& operator<<(std::ostream& out, const PerOperationSamplingStrategies& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PerOperationSamplingStrategies::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_defaultSamplingProbability = false;
  bool isset_defaultLowerBoundTracesPerSecond = false;
  bool isset_perOperationStrategies = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->defaultSamplingProbability);
          isset_defaultSamplingProbability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->defaultLowerBoundTracesPerSecond);
          isset_defaultLowerBoundTracesPerSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->perOperationStrategies.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->perOperationStrategies.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->perOperationStrategies[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_perOperationStrategies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->defaultUpperBoundTracesPerSecond);
          this->__isset.defaultUpperBoundTracesPerSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_defaultSamplingProbability)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultLowerBoundTracesPerSecond)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_perOperationStrategies)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PerOperationSamplingStrategies::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PerOperationSamplingStrategies");

  xfer += oprot->writeFieldBegin("defaultSamplingProbability", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->defaultSamplingProbability);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultLowerBoundTracesPerSecond", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->defaultLowerBoundTracesPerSecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perOperationStrategies", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->perOperationStrategies.size()));
    std::vector<OperationSamplingStrategy> ::const_iterator _iter11;
    for (_iter11 = this->perOperationStrategies.begin(); _iter11 != this->perOperationStrategies.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.defaultUpperBoundTracesPerSecond) {
    xfer += oprot->writeFieldBegin("defaultUpperBoundTracesPerSecond", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->defaultUpperBoundTracesPerSecond);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PerOperationSamplingStrategies &a, PerOperationSamplingStrategies &b) {
  using ::std::swap;
  swap(a.defaultSamplingProbability, b.defaultSamplingProbability);
  swap(a.defaultLowerBoundTracesPerSecond, b.defaultLowerBoundTracesPerSecond);
  swap(a.perOperationStrategies, b.perOperationStrategies);
  swap(a.defaultUpperBoundTracesPerSecond, b.defaultUpperBoundTracesPerSecond);
  swap(a.__isset, b.__isset);
}

PerOperationSamplingStrategies::PerOperationSamplingStrategies(const PerOperationSamplingStrategies& other12) {
  defaultSamplingProbability = other12.defaultSamplingProbability;
  defaultLowerBoundTracesPerSecond = other12.defaultLowerBoundTracesPerSecond;
  perOperationStrategies = other12.perOperationStrategies;
  defaultUpperBoundTracesPerSecond = other12.defaultUpperBoundTracesPerSecond;
  __isset = other12.__isset;
}
PerOperationSamplingStrategies& PerOperationSamplingStrategies::operator=(const PerOperationSamplingStrategies& other13) {
  defaultSamplingProbability = other13.defaultSamplingProbability;
  defaultLowerBoundTracesPerSecond = other13.defaultLowerBoundTracesPerSecond;
  perOperationStrategies = other13.perOperationStrategies;
  defaultUpperBoundTracesPerSecond = other13.defaultUpperBoundTracesPerSecond;
  __isset = other13.__isset;
  return *this;
}
void PerOperationSamplingStrategies::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PerOperationSamplingStrategies(";
  out << "defaultSamplingProbability=" << to_string(defaultSamplingProbability);
  out << ", " << "defaultLowerBoundTracesPerSecond=" << to_string(defaultLowerBoundTracesPerSecond);
  out << ", " << "perOperationStrategies=" << to_string(perOperationStrategies);
  out << ", " << "defaultUpperBoundTracesPerSecond="; (__isset.defaultUpperBoundTracesPerSecond ? (out << to_string(defaultUpperBoundTracesPerSecond)) : (out << "<null>"));
  out << ")";
}


SamplingStrategyResponse::~SamplingStrategyResponse() throw() {
}


void SamplingStrategyResponse::__set_strategyType(const SamplingStrategyType::type val) {
  this->strategyType = val;
}

void SamplingStrategyResponse::__set_probabilisticSampling(const ProbabilisticSamplingStrategy& val) {
  this->probabilisticSampling = val;
__isset.probabilisticSampling = true;
}

void SamplingStrategyResponse::__set_rateLimitingSampling(const RateLimitingSamplingStrategy& val) {
  this->rateLimitingSampling = val;
__isset.rateLimitingSampling = true;
}

void SamplingStrategyResponse::__set_operationSampling(const PerOperationSamplingStrategies& val) {
  this->operationSampling = val;
__isset.operationSampling = true;
}
std::ostream& operator<<(std::ostream& out, const SamplingStrategyResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SamplingStrategyResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_strategyType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->strategyType = (SamplingStrategyType::type)ecast14;
          isset_strategyType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->probabilisticSampling.read(iprot);
          this->__isset.probabilisticSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rateLimitingSampling.read(iprot);
          this->__isset.rateLimitingSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationSampling.read(iprot);
          this->__isset.operationSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_strategyType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SamplingStrategyResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SamplingStrategyResponse");

  xfer += oprot->writeFieldBegin("strategyType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->strategyType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.probabilisticSampling) {
    xfer += oprot->writeFieldBegin("probabilisticSampling", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->probabilisticSampling.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rateLimitingSampling) {
    xfer += oprot->writeFieldBegin("rateLimitingSampling", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->rateLimitingSampling.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationSampling) {
    xfer += oprot->writeFieldBegin("operationSampling", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->operationSampling.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SamplingStrategyResponse &a, SamplingStrategyResponse &b) {
  using ::std::swap;
  swap(a.strategyType, b.strategyType);
  swap(a.probabilisticSampling, b.probabilisticSampling);
  swap(a.rateLimitingSampling, b.rateLimitingSampling);
  swap(a.operationSampling, b.operationSampling);
  swap(a.__isset, b.__isset);
}

SamplingStrategyResponse::SamplingStrategyResponse(const SamplingStrategyResponse& other15) {
  strategyType = other15.strategyType;
  probabilisticSampling = other15.probabilisticSampling;
  rateLimitingSampling = other15.rateLimitingSampling;
  operationSampling = other15.operationSampling;
  __isset = other15.__isset;
}
SamplingStrategyResponse& SamplingStrategyResponse::operator=(const SamplingStrategyResponse& other16) {
  strategyType = other16.strategyType;
  probabilisticSampling = other16.probabilisticSampling;
  rateLimitingSampling = other16.rateLimitingSampling;
  operationSampling = other16.operationSampling;
  __isset = other16.__isset;
  return *this;
}
void SamplingStrategyResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SamplingStrategyResponse(";
  out << "strategyType=" << to_string(strategyType);
  out << ", " << "probabilisticSampling="; (__isset.probabilisticSampling ? (out << to_string(probabilisticSampling)) : (out << "<null>"));
  out << ", " << "rateLimitingSampling="; (__isset.rateLimitingSampling ? (out << to_string(rateLimitingSampling)) : (out << "<null>"));
  out << ", " << "operationSampling="; (__isset.operationSampling ? (out << to_string(operationSampling)) : (out << "<null>"));
  out << ")";
}

}}} // namespace
